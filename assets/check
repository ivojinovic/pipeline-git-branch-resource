#!/bin/sh
# vim: set ft=sh

set -e

exec 3>&1 # make stdout available as fd 3 for the result
exec 1>&2 # redirect all output to stderr for logging

source $(dirname $0)/common.sh

# for jq
PATH=/usr/local/bin:$PATH

payload=$TMPDIR/git-resource-request
cat > $payload <&0
load_pubkey $payload
configure_git_ssl_verification $payload
configure_credentials $payload

# TODO: Improve this source param name: should be app, not project
app_git_uri=$(jq -r '.source.project_git_uri // ""' < $payload)
old_ref=$(jq -r '.version.ref // ""' < $payload)

# Get the list of active (unmerged to master) dev branches
app_repo_dir=$TMPDIR/git-resource-repo-cache-1
/opt/resource/clone_git_repo_into_directory.sh $app_git_uri $app_repo_dir
cd $app_repo_dir
# TODO: Test code: REMOVE! | sed '/test-/!d'
ACTIVE_DEV_BRANCHES=$(git branch -r --no-merged | sed "s/origin\///" | sed '/test-/!d' | xargs)

# Get the sha of the latest commit of the pipelines project
# TODO: This needs to be a parameter
pipelines_git_uri=ssh://git@stash.zipcar.com:7999/sav/pipelines.git
pipelines_repo_dir=$TMPDIR/git-resource-repo-cache-2
/opt/resource/clone_git_repo_into_directory.sh $pipelines_git_uri $pipelines_repo_dir
cd $pipelines_repo_dir
# TODO: This needs to be a parameter
git checkout dynamic-dev-branches
PIPELINEST_LAST_SHA=$(git rev-parse HEAD)

# Check if the current pipeline has the groups it should have (in other words: was it recently repipied and the dev branches haven't been expanded yet)
echo "true" > /opt/resource/pipeline_has_correct_groups.out
/opt/resource/pipeline_has_correct_groups.sh $payload "$ACTIVE_DEV_BRANCHES"
PIPELINE_HAS_CORRECT_GROUPS=`cat /opt/resource/pipeline_has_correct_groups.out`

# Now, put it all together
new_ref="$ACTIVE_DEV_BRANCHES $PIPELINEST_LAST_SHA"
if [ "$PIPELINE_HAS_CORRECT_GROUPS" != "true" ] ; then
    TIMESTAMP=$(date +%s)
    new_ref="$new_ref $TIMESTAMP"
fi

# Debug code
# curl -X POST -d "PIPELINE_HAS_CORRECT_GROUPS=$PIPELINE_HAS_CORRECT_GROUPS&new_ref=new_ref" http://requestb.in/11iyz2d1

if [ "${ref}" = "${new_ref}" ]; then
    echo '[{ "ref": "'$old_ref'" }]' >&3
else
    echo '[{ "ref": "'$old_ref'" }, { "ref": "'$new_ref'" }]' >&3
fi
